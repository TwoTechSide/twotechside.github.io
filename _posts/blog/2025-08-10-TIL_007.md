---
title: "[TIL] Spring - @Column(unique = true) 에러 핸들링"
date: 2025-08-10 16:00:00 +0900
categories: [Blog, TIL]
tags: [TIL, Spring, Java, JPA]
---

## 1. @Column(Unique = true)

```java
// Entity, Getter 등 어노테이션을 쓰고
public class User extends BaseTntity {
   // entity 필드를 붙여넣었는데..
   @Column(unique = true)
    private String email;
}
```

> 유니크 제약 : 각 데이터가 모두 유일(unique)함을 보장하는 제약으로, 쉽게 말해 모든 데이터에 중복이 없어야 합니다  
  
여기서 `email` 필드에 유니크 제약을 걸고, 어떤 에러가 발생하는지 테스트를 작성해보면  
콘솔에 분명 `SQLIntegrityConstraintViolationException`이 발생하는 것을 볼 수 있을겁니다  
  
그러면 대충 `try-catch`에 위 예외를 잡아서 처리하면 되지 않을까요  

<br>
- - -
  
## 2. 문제 발생 및 해결  

- Service 레이어의 `@Transactional`이 붙은 DB 저장 메서드
  
![img](/assets/img/postimg2/postimg050.png)  
  
그런데 `try-catch`에 작성해보면 해당 예외가 한 번도 던져지지 않았다는 오류가 뜹니다  
테스트에서는 뜨는데 그러면 뭐가 문제라는 내용일까.. 더 알아낼 방법이 보이지 않아 구글링릏 배왔습니다  
  
- Q. [Stackoverflow - How to handle the SQLIntegrityConstraintViolationException in Spring Boot?](https://stackoverflow.com/questions/54035808/how-to-handle-the-sqlintegrityconstraintviolationexception-in-spring-boot)  
- A. "엔티티를 저장할 때에는 `SQLException` 대신 `DataIntegrityViolationException`을 사용하세요"  
  
혹시 `try-catch`를 작성하지 않았을 때 발생한 오류에서  
`DataIntegrityViolationException`에 대한 정보가 나오지 않을까 싶어서 둘러보니 있었습니다  
  
> ERROR 36316 --- [nio-8080-exec-1] o.a.c.c.C.[.[.[/].[dispatcherServlet] : Servlet.service() for servlet [dispatcherServlet] in context with path [] threw exception [Request processing failed: org.springframework.dao.**<u>DataIntegrityViolationException</u>** 이후 어쩌구저쩌구..
  
`catch`문 안에 `DataIntegrityViolationException`로 고쳐서 잡아보면 예외를 잘 처리해주는 것을 알 수 있습니다  
사실 원인을 더 자세히 알아보고 싶었는데 현재 지식으로는 한계가 있어서 정확히 설명드리지 못하는 것이 아쉽습니다  
  
  
<br>
- - -

## 3. 식별자의 값 상태가..
  
예외 처리까진 해결했는데 막상 DB를 조회해보면 `Long` 타입의 고유 식별자, PK값이 1씩 증가하지 않고  
예외가 발생했던 만큼도 추가로 뛰어넘으면서 값이 들어가지게 됩니다 (1, 2, 4, 10, 11, ...)  
  
이 부분은 `@GeneratedValue(strategy = GenerationType.IDENTITY)`을 사용하는 **IDENTITY 전략**과 관계가 있는데  
예외가 발생하여 트랜잭션 롤백이 이루어져도 **(auto_increment)**값이 증가된 상태로 남아있기 때문입니다  
  
PK 값은 **유일성**이 중요하기 때문에 신경쓰지 않아도 괜찮지만  
만약 이 문제도 해결하려면 Repository의 `existsBy..`로 사전 검증을 한 뒤에 데이터를 넣어주거나  
PK와는 별도의 값을 가지는 번호 필드를 추가하는 것이 좋을 것 같습니다  