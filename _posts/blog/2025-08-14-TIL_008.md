---
title: "[TIL] 개인 프로젝트 - '일정 관리 (숙련) 프로젝트' 후기"
date: 2025-08-14 13:00:00 +0900
categories: [Blog, TIL]
tags: [TIL, Spring, Java, JPA]
---

## 1. 일정 관리 (숙련) 프로젝트  
  
저번의 일정 관리 프로젝트에서 더욱 어려워진 프로젝트입니다  
  
이전보다 훨씬 다양한 내용을 적용해보며 프로젝트를 협업하는 사람이 보아도  
손쉽게 유지보수할 수 있도록 만드는게 이번 프로젝트의 목표라고도 볼 수 있겠습니다  
    
이번에는 글이 조금 길 수도 있겠네요  
  
<br>
- - -

## 2. 새롭게 배운 내용들

### 2-1. Issue, Pull Request 템플릿
  
이전의 내용을 다시 열어보고 틀에 맞춰 작성해야 한다는게 꽤나 귀찮은 작업인 것 같습니다  
그런데 이전에 함께 프로젝트를 하던 팀원분께서 꽤 좋은 팁을 주더라구요  
  
1. Issue Template  
   [ 깃허브 Repository - General - Features - Set up templates ]  
   이슈 템플릿을 만들 수 있습니다  
   기획, 추가할 기능, 개선 사항 등을 템플릿으로 만들고, 이후 살만 조금 붙여서 쉽게 Issue를 등록할 수 있습니다  

2. Pull Request Template  
   [ Repository Main\\\.github\ISSUE_TEMPLATE\pull_request_template.md ]  
   Pull Request 내용이 자동으로 해당 템플릿으로 채워집니다  
   어느 이슈와 관련된 것인지, 어떤 기능을 추가하거나 삭제, 수정을 한 것인지 체크하는 템플릿이 상당히 유용합니다  

![img](https://images.ctfassets.net/fczckc3dt6mv/26xU5pqqBCYrS0asdSmTpr/78c5f48843c147070ee873248ebe06b5/patrick_05-23-18_04.png?w=1200&q=75)  
- 예시 출처 : [sparkbox](https://sparkbox.com/foundry/better_pull_requests_merge_requests_with_templates)  


<br>
- - -

### 2-2. MapStruct  

`Entity`와 `DTO`를 서로 변환하는 작업은 상당히 자주 필요합니다  
그런데 서로 변환해주는 작업의 방법이 다양하더라구요  
  
1. `@Builder`  
2. `@AllArgsConstructor(생성자)`  
3. `정적 팩토리 메서드`  
4. `MapStruct`  
  
1~3번은 알고 있는 내용이지만 (정적 팩토리 메서드와 같은 '디자인 패턴'은 조만간 글로 작성할 예정)  
4번의 `MapStruct`는 처음 보게된 방법이기 때문에 이 참에 적용해보려고 합니다  
  
```java
// 종속성 추가
deptendencies {
    implementation 'org.mapstruct:mapstruct:1.4.2.Final'
    annotationProcessor 'org.mapstruct:mapstruct-processor:1.4.2.Final'
}


// Mapper 클래스 추가
@Mapper(componentModel = "spring")  // Bean으로 지정하려면 'componentModel' 지정
public interface MapperClass {

    Entity toEntity(RequestDto requestDto);  // request dto -> entity
    ResponseDto toDto(Entity entity);        // entity -> response dto
}

// 사용 예시 > Service
// private final MapperClass mapperClass;   - @RequiredArgsConstruct로 주입
// Entity entity = mapperClass.toEntity(requestDto)
```

만약 entity와 dto 둘 다 같은 필드를 가지고 있는 경우, 자동으로 값을 매핑해주며 변환하게 됩니다  
생성자나 빌더, 정적 팩토리 메서드와 다르게 별다른 긴 코드를 작성할 필요가 없습니다  

<br>
  
```java
// Entity의 password 필드에는 encodedPassword 값을 매핑
// 만약 source와 target에 있는 같은 목적의 다른 필드명도 @Mapping 사용으로 매핑 가능
@Mapping(source = "encodedPassword", target = "password")
Entity toEntityWithNewField(RequestDto requestDto, String encodedPassword)


// Entity -> Dto 매핑 작업에 이름 지정
@Named("toResponseDto(entity)")
ResponseDto toResponseDto(Entity entity);

// List는 지정된 매핑 작업으로 iterate 작업
@IterableMapping(qualifiedByName = "toResponseDto(entity)")
List<ResponseDto> toResponseDto(List<Entity> entities)
```
필드명이 다른 값을 매핑해야하거나 새로운 인자를 넣어줘야 하는 경우  
또는 `List` 형태도 손쉽게 어노테이션으로 지정하여 사용할 수 있습니다  

<br>
- - -

### 2-3.  
   
\> 임시 저장 <