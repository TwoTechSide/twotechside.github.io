---
title: "[TIL] 개인 프로젝트 - '일정 관리 (숙련) 프로젝트' 후기"
date: 2025-08-14 13:00:00 +0900
categories: [Blog, TIL]
tags: [TIL, Spring, Java, JPA]
---

## 1. 일정 관리 (숙련) 프로젝트  
  
저번의 일정 관리 프로젝트에서 더욱 어려워진 프로젝트입니다  
  
이전보다 훨씬 다양한 내용을 적용해보며 프로젝트를 협업하는 사람이 보아도  
손쉽게 유지보수할 수 있도록 만드는게 이번 프로젝트의 목표라고도 볼 수 있겠습니다  
    
이번에는 글이 조금 길 수도 있겠네요  
  
<br>
- - -

## 2. 새롭게 배운 내용들

### 2-1. Issue, Pull Request 템플릿
  
이전의 내용을 다시 열어보고 틀에 맞춰 작성해야 한다는게 꽤나 귀찮은 작업인 것 같습니다  
그런데 이전에 함께 프로젝트를 하던 팀원분께서 꽤 좋은 팁을 주더라구요  
  
1. Issue Template  
   [ 깃허브 Repository - General - Features - Set up templates ]  
   이슈 템플릿을 만들 수 있습니다  
   기획, 추가할 기능, 개선 사항 등을 템플릿으로 만들고, 이후 살만 조금 붙여서 쉽게 Issue를 등록할 수 있습니다  

2. Pull Request Template  
   [ Repository Main\\\.github\ISSUE_TEMPLATE\pull_request_template.md ]  
   Pull Request 내용이 자동으로 해당 템플릿으로 채워집니다  
   어느 이슈와 관련된 것인지, 어떤 기능을 추가하거나 삭제, 수정을 한 것인지 체크하는 템플릿이 상당히 유용합니다  

![img](https://images.ctfassets.net/fczckc3dt6mv/26xU5pqqBCYrS0asdSmTpr/78c5f48843c147070ee873248ebe06b5/patrick_05-23-18_04.png?w=1200&q=75)  
- 예시 출처 : [sparkbox](https://sparkbox.com/foundry/better_pull_requests_merge_requests_with_templates)  


<br>
- - -

### 2-2. MapStruct  

`Entity`와 `DTO`를 서로 변환하는 작업은 상당히 자주 필요합니다  
그런데 서로 변환해주는 작업의 방법이 다양하더라구요  
  
1. `@Builder`  
2. `@AllArgsConstructor(생성자)`  
3. `정적 팩토리 메서드`  
4. `MapStruct`  
  
1~3번은 알고 있는 내용이지만 (정적 팩토리 메서드와 같은 '디자인 패턴'은 조만간 글로 작성할 예정)  
4번의 `MapStruct`는 처음 보게된 방법이기 때문에 이 참에 적용해보려고 합니다  
  
```java
// 종속성 추가
deptendencies {
    implementation 'org.mapstruct:mapstruct:1.4.2.Final'
    annotationProcessor 'org.mapstruct:mapstruct-processor:1.4.2.Final'
}


// Mapper 클래스 추가
@Mapper(componentModel = "spring")  // Bean으로 지정하려면 'componentModel' 지정
public interface MapperClass {

    Entity toEntity(RequestDto requestDto);  // request dto -> entity
    ResponseDto toDto(Entity entity);        // entity -> response dto
}

// 사용 예시 > Service
// private final MapperClass mapperClass;   - @RequiredArgsConstruct로 주입
// Entity entity = mapperClass.toEntity(requestDto)
```

만약 entity와 dto 둘 다 같은 필드를 가지고 있는 경우, 자동으로 값을 매핑해주며 변환하게 됩니다  
생성자나 빌더, 정적 팩토리 메서드와 다르게 별다른 긴 코드를 작성할 필요가 없습니다  

<br>
  
```java
// Entity의 password 필드에는 encodedPassword 값을 매핑
// 만약 source와 target에 있는 같은 목적의 다른 필드명도 @Mapping 사용으로 매핑 가능
@Mapping(source = "encodedPassword", target = "password")
Entity toEntityWithNewField(RequestDto requestDto, String encodedPassword)


// Entity -> Dto 매핑 작업에 이름 지정
@Named("toResponseDto(entity)")
ResponseDto toResponseDto(Entity entity);

// List는 지정된 매핑 작업으로 iterate 작업
@IterableMapping(qualifiedByName = "toResponseDto(entity)")
List<ResponseDto> toResponseDto(List<Entity> entities)
```
필드명이 다른 값을 매핑해야하거나 새로운 인자를 넣어줘야 하는 경우  
또는 `List` 형태도 손쉽게 어노테이션으로 지정하여 사용할 수 있습니다  
  
> 단, Source에는 getter가 있어야하고 Target에는 builder이나 setter, 생성자 등이 포함되어야 합니다
{:.prompt-info}

<br>
- - -

### 2-3. Record 클래스

```java
public record Person(String name,
                     int age,
                     String email) {

}
```

JDK 14에서 Preview로 등장했다가 JDK 16에 정식으로 포함된 클래스입니다  
`record`를 사용할 경우 다음 내용들이 자동으로 구현됩니다  
  
- 필드 캡슐화 (`private final`)
- 생성자
- getter
- equals
- hashcode
- toString

getter에서 약간의 차이점이 생기는데, `get<필드명>()`대신 `<필드명>()`으로 값을 가져옵니다  
스프링에서 Request/Response DTO에 적용할 때 유용하게 사용할 수 있을 것 같습니다  
  
> 단, JPA와 같이 사용하는 것에는 문제가 생기므로 `Entity`에 `record`를 사용할 수는 없습니다  
> 자세한 이유는 한 번 찾아보는 것이 좋겠습니다  
{:.prompt-tip}

<br>
- - -

### 2-4. HandlerMethodArgumentResolver
  
`session`에 저장된 유저 ID값을 `Controller`에서 꺼내야하는 수고가 있을 수도 있습니다  
하지만 `Controller` 레이어의 파라미터에서 바로 엔티티로 반환해주는 객체가 있다면 좋지 않을까요  
  
```java
// ScheduleController.java ... 일정 생성
@PostMapping
public ResponseEntity<ScheduleResponseDto> createSchedule(
        @RequestBody @Valid ScheduleCreateRequestDto scheduleCreateRequestDto,
        @LoginUserResolver User user) {

    ScheduleResponseDto createdScheduleDto = scheduleService.createSchedule(scheduleCreateRequestDto, user);
    return ResponseEntity.status(HttpStatus.CREATED).body(createdScheduleDto);
}
```

제가 프로젝트에 사용했던 API중 하나인데 `@LoginUserResolver` 어노테이션을 사용했습니다  
`Body`에 user 데이터를 넣지 않고 `session`으로 유저의 id값만 가져가는데도 엔티티 객체를 사용할 수 있죠  
  
`ArgumentResolver`라는 것을 이용해서..  
**Controller로 들어온 파라미터를 엔티티 객체로 가공하는 방법**을 간단하게 보겠습니다  
  
<br>

```java
@Target(ElementType.PARAMETER)       // -> 메소드의 파라미터로 선언된 객체에서만 사용 가능
@Retention(RetentionPolicy.RUNTIME)  // -> 메모리 생명 주기를 RUNTIME으로 지정
public @interface LoginUserResolver {

}
```
- 특이하게도 클래스가 아닌 `@interface`로 지정합니다  

<br>

```java
@Component
@RequiredArgsConstructor
public class UserHandlerArgumentResolver implements HandlerMethodArgumentResolver {

    private final HttpSession httpSession;
    private final UserRepository userRepository;

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        return parameter.getParameterType().isAssignableFrom(User.class);
    }

    @Override
    public User resolveArgument(MethodParameter parameter,
                                ModelAndViewContainer mavContainer,
                                NativeWebRequest webRequest,
                                WebDataBinderFactory binderFactory) {

        Object userId = httpSession.getAttribute("LOGIN_USER_ID");

        if (Objects.isNull(userId)) {
            throw new BusinessException(ErrorCode.INTERVAL_SERVER_ERROR);
        }

        Optional<User> optionalUser = userRepository.findById((Long) userId);
        return optionalUser.orElseThrow(() -> new BusinessException(ErrorCode.USER_NOT_FOUND));
    }
}
```

- `HandlerMethodArgumentResolver`을 상속받아 컨트롤러 메서드의 파라미터를 처리할 수 있도록 합니다  
- **supportsParameter**는 `boolean`값에 따라 `resoveArgument` 메서드를 실행할지 결정합니다  
- **resolveArgument**메서드 에서 `userRepository`에 찾은 유저 엔티티를 반환합니다  

이후 컨트롤러에 어노테이션을 붙여주면 session 값을 불러온 뒤 유저 엔티티를 불러오게 됩니다  

<br>
- - -
  
## 3. 조금 더 보완된 내용  

### 3-1. @ManyToOne(fetch = FetchType.LAZE)
  
```java
// Schedule.java
@ManyToOne(fetch = FetchType.LAZY)
@JoinColumn(name = "user_id")
private User user;
```

`Schedule`과 `User`가 N:1 관계일 때, `@ManyToOne`으로 단방향 연관관계를 설정할 수 있습니다  
  

\>임시저장<